# 背景

一个大型的项目历时较长，期间会有许多软件人员参与项目的软件开发。不同的开发人员有着不同的经历和背景，其编程风格可能不仅会与项目既有的有显著的差异，而且与其他开发人员的编程风格也差别迥异。

这导致了项目内编程风格的不一致，会对其他的开发人员，测试人员和分析人员造成不必要的困扰。

保持统一的编程风格并遵守约定，不仅可以使代码更易于管理，也意味着可以和容易的根据“模式匹配”规则来推断各种标识符的含义。创建通用的，必需的习惯用语和模式，使代码更容易理解。

本指南不同于编码规范，尽管部分内容可能会与编码规范有重叠。本指南是推荐性的，而规范具有强制性。

本指南参考 [Goolge C++ Coding Style](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/) 并对其做适当删减和修改以符合项目的需要。

使用[MdtoPDF](http://mdtr2pdf.com/)可将MarkDown格式的文本转换成`PDF`格式
******

# 头文件

通常每一个`.c`文件都有一个对应的`.h`文件。也有一些常见的例外，比如单元测试代码和只包含`main()`函数的`.c`文件

正确使用头文件可令代码在可读性、文件大小和性能上大为改观。

下面的规则将引导你规避使用头文件时的各种陷阱。


## Self-contained 头文件
> **头文件应该能够自给自足（self-contained, 也就是可以作为第一个头文件引入），以`.h`结尾**


所有的头文件要能够自给自足。换言之，头文件自身应包含其需要的所有资源，不需要用户为其包含额外的内容。为了达到该要求，一个头文件需要:
+ define保护
+ 包含其需要的所有其他头文件
+ 不要求定义任何特殊的符号(symbols)

## define保护
> **所有头文件都应该使用`#define`保护来防止头文件被多重包含，命名格式应为`_<PROJECT>_<PATH>_<FILE>_H_`**


为了保证唯一性，头文件的命名应基于所在项目源代码树的全路径，比如，项目`foo`中头文件`foo/src/bar/baz.h`可按如下方式保护

	#ifndef _FOO_BAR_BAZ_H_
	#define _FOO_BAR_BAZ_H_
	...
	#endif
	

## 前置声明
> **尽量避免使用前置声明。使用`#inlcude`包含需要的头文件即可**

### 定义

前置声明是针对类型、变量或者函数的声明。前置声明是个不完整类型。

### 优点
前置类型可以有效的避免头文件的循环包含。比如在`circle.h`中:


	#include "point.h"
	
	struct circle {
		struct coordinate center;
	};
	
	
在`point.h`中:
	
	#include "circle.h"
	
	struct coorinate {
		struct circle cir;
	};	
	
	
上述的程序，会出现头文件循环包含的问题，所以是无法通过编译的。
   
如果`circle.h`改成如下的形式
    
	//#include "point.h"
	
	struct coordinate;
	
	struct circle {
		struct coordinate * center;
	};
 
	
通过对`coordinate`的前置声明，解决了这个问题。但是必须要使用指针，因为使用了前置声明后，对于`center.h`而言`coordinate`是个不完整类型，无法分配存储空间，必须使用指针。

由此可见使用前置声明，可以不在使用`#include`，所以
+ 使用前置声明，由于不在需要因为`#include`展开很多的头文件，处理更多的输入，节省了编译时间。
+ 使用前置声明，由于不在被`#include`中无关的改动所影响，节省了重编译的编译时间。


### 缺点
前置声明的缺点和优点一样的明显。既然不需要`#include`，那么

+ 前置声明隐藏了依赖关系，头文件改动后，代码会跳过必要的重编译过程
+ 前置声明会被库的后续更改破坏。前置声明函数时，会妨碍头文件开发者变动其API。
+ 贸然使用前置声明，会导致代码发生不可以估计的改变


### 例外
在C语言当中，不完整类型是其提供实现抽象封装的唯一办法。比如某个模块实现是一个封装好的功能，并提供了API。为了让用户使用API而又不暴露封装的内部细节，只能使用不完整类型（前置声明）
比如在`.h`中声明了结构体以及API

	// file.h
	
	struct MyStruct;
	
	...
	
	// declaration of API
	...
	

在`.c`中定义了结构体和API

	// file.c
	
	struct MyStruct {
	...
	};
	
	// definition of API
	...
	
这样可以避免将结构体定义在`.h`文件中，暴露了具体封装。


### 结论
+ 尽量避免前置声明那些定义在其他项目中的实体.
+ 为了实现抽象封装而使用前置声明，则必须在其对应的`.c`文件中提供直接定义
+ 函数：总是使用`#include`

	
## `#include`的路径及顺序
> **使用标准的头文件包含顺序可增强可读性，避免隐藏依赖。其顺序应为：相关头文件，系统文件，其他库的`.h`，本项目的`.h`**


项目内头文件应该按照项目源代码目录树结构排列，避免使用UNIX特殊的快捷路径`.`（当前目录）或`..`(上级目录）。
例如`project/src/base/logging.h`应使用如下的方式包含：
	
	#include "base/logging.h"
	
又如，`dir/foo.c`或者`dir/foo_test.c`的主要作用是实现或者测试`dir2/foo2.h`的功能，`foo.c`的头文件包含次序如下

1. `dir2/foo2.h`
2. 系统头文件
3. 其他库的`.h`文件
4. 本项目的`.h`文件

这种优先的顺序排序保证了当`dir2/foo2.h`遗漏了某些必要的库是，`dir/foo.c`或者`dir/foo_test.c`的构建会立刻终止。因此这一规则保证首先看到构建终止的消息
的是这些文件的维护者，而不是它们使用者。

你所依赖的符号被那些头文件所定义，那就是应该包含哪些头文件。
比如要用到`bar.h`中的符号，那就应该是包含`bar.h`。如果被你包含的`foo.h`也同样包含了`bar.h`,除非`foo.h`明确说明它会提供`bar.h`所有的符号，否则你必须也同样包含`bar.h`

对于既有的项目，建议在有机会修改的时候修改其`#include`的顺序

******
# 作用域

## 静态变量

> **在`.c`文件中定义了一个不需要被外部引用的变量时，将其声明为`static`。但是不要在`.h`文件中这么做**

变量在被声明为`static`后，意味着该变量不能再另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，他们所指向的实体实际是完全不同的。




## 局部变量
> **将函数变量尽可能置于最小的作用域内，并在变量声明时进行初始化。**

C语言允许在刚开始进入`{...}`语句块是，定义局部变量


## 函数的作用域

> **Tips**: 如果定义了某些函数，又只在相同的`.c`文件中使用它，可用`static`关键字修饰以限定其作用域; 
> 如果函数需要被外部引用（比如API），应在`.h`文件中用`extern`声明，并在`.c`文件中定义


******
# 函数

## 参数顺序

> **函数的参数顺序为： 输入参数在前；输出参数在后**

C中的函数参数或者是函数的收入，或者是函数的输出，或者兼而有之。输入参数通常是值参数或者`const`指针；输出参数或者输入/输出参数一般是非`const`指针。在排列参数顺序时，将所有的
输入参数置于输出参数之前。**特别注意的是，不要因为新的参数是新增的而至于参数列表的后面**，而是依然要按照前述的规则，即将新的输入参数也置于输出参数的前面

这并非是一个硬性的规定。输入/输出参数（一般是结构体指针）让这个问题变得有些复杂，并且可能不得不有所变通。但请尽量保持该规则。

## 编写短函数
> **尽量编写简短，凝练的函数**

长函数有其和灵性，因此并不能硬性呆板的限制函数长度。但是如果函数长度超过40行，可以思考是否能不再影响程序结构的前提下进行分割

即使一个长函数现在工作良好，一旦对其改动，有可能出现新的问题，进而导致难以发现的Bug. 使函数尽量简短，以便于他人阅读和修改代码。

在处理代码时，可能会发现复杂的长函数。不要害怕修改：如果证实这些代码使用/调试/维护很困难，考虑将其分割成简短并更利于管理的若干函数.



******
#  命名约定

项目中最重要的一致性规则是命名惯例。命名的风格能让我们在不需要查找类型声明的条件下快速的了解某个名字代表的含义：类型，变量，函数，宏，等等。

我们大脑中模式匹配功能非常的依赖这些命名规则。

命名规则具有一定的随意性。但是相比按照个人喜好，一致性更重要。


## 通用命名
> **函数命名，变量命名，文件命名要有描述性，少用缩写.**

尽可能用描述性的命名，别心疼代码的空间，毕竟相比之下代码易于新读者理解更重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个子母来缩写单词。


	int price_count_reader;  // 无缩写
	int num_usr;             // num 和 usr都是通用缩写
	int num_dns_connections; // dns是术语
	
	int n;                   // 没有明确意义
	int nerr;                // 含糊不清的缩写
	int n_conns;             // 含糊不清的缩写
	int wgc_connections;     // wgc是什么含义
	int pc_reader;           // pc的含义不明确
	int cstmr_id;            // cstmr什么意思,删减了部分字母
	

当然一些广为人知的缩写是可以的，比如`i，j`表示迭代变量




## 文件命名
> **文件名称全部用小写，可以包含下划线`_`(但是不要至于头/尾）**

可接受的文件命名实例:

+ `my_test.c`
+ `my_class.c`
+ `myclass.h`

下面的命名不接受:

+ `_my_test_.c`
+ `MYTEST.h`
+ `my_test_.c`

尽量让文件名更明确，比如`http_server_log.h`比`log.h`更明确含义

如果可能，建议采用`<MODULE_NAME>_<FILE>`来给文件命名，比如:
+ `um_test.c`
+ `guest_logging.h`
+ `tcim25_input.c`

## 类型命名
> **类型名称的每个单词首字符均大写，不包括下划线。名词或者名词词性**


所有的类型命名，结构体，类型定义均使用同样的规则，以大写字母开始，每个单词首字母均大写。比如

	struct MyClass {...};
	typedef int MyInt;
	

## 变量命名
> **变量(包括函数参数）和数据成员命名采用首字母小写，后续单次的每个首字母大写(驼峰）。采用名词或者名词词性。**

### 普通变量命名
举例:

	int counter;
	int dataLen;
	char * tableName;
	
### 结构体成员变量	
举例:

	strcut MyStruct {
	    int    counter;
	    char * tableName;
	    int    dataSize;
	}
	
## 函数命名

> **函数采用大小写混合，取值和设值函数要求与变量名匹配。函数尽量采用动词或者动词词性,使用谓+宾的命名方式。**

函数名的首字母小写，后续每个单词字母大写，没有下划线。对于首字母缩写的单词，更倾向将它们全部大写。比如`initTFTP`而非`initTftp`。

举例

	addTableEntry()
	deleteURL()
	openFile()
	
取值或者设值函数的命名与变量名尽量匹配。比如结构体中变量`int counter`，则取值函数设置为`int getCounter()`，设置函数命名为`void setCounter()`


## 宏命名
> **宏命名全部大写，单次之间采用下划线**

举例:

	#define MY_MACRO_THAT_SCARES_SMALL_CHILDREN 
	#define SECOND_PER_MIN

	
## 枚举命名
> **枚举数据其数据类型定义采用类型命名的规则，内部枚举变量的命名与宏保持一致**

举例:

	enum ScheduleState {
	    READY_STATE = 0;
		RUNNING_STATE = 1;
		...
	}

## MSTEP命名前缀
> **函数，全局变量，静态变量定义，宏定义，结构体定义，枚举定义命名前需要添加前缀**


为了和平台内核的命名规则保持一致，在命名前添加前缀, 前缀命名规则为`<MODULE_NAME>_<TYPES>_<SUB_MODULE>`

其中`<MODULE_NAME>`分类包括
+ MSTEP
+ OSW
+ GDF
+ STD
+ GDF
+ GUEST
+ 板卡名称: SDDM, SIOM等具体板卡的名称(大写）
+ UM: 通用模块

其中`<TYPES>`分类包括
+ T: 自定义`struct`或者`typedef`类型
+ E: 枚举类型
+ C: 宏常量
+ M: 宏语句块/宏函数
+ V: 静态/全局变量
+ F: 函数

`<SUB_MODULE>`各自定义，要求
+ 一个名词或者名词词性
+ 首字符大写，比如`Fuse`和`Maintenace`
+ 如果是缩写则全部大写,比如`SSR`和`TFTP`

前缀和命名最终构成完整命名 `<MODULE_NAME>_<TYPES>_<SUB_MODULE>_<NAME>`	

**`<NAME>`域的命名规则徐符合本章节所述的内容**
	
******
# 注释

**后续完善，符合Doxygen的注释风格**

******
# 格式
每个人都可能有自己的代码风格和格式，但如果一个项目中的所有人都遵循同一个风格的话，这个项目就能更顺利的进行。每个人
未必能同意下述的每一处格式规则，而且其中的不少规则需要一定时间的实行，但是整个项目服从统一的编码风格是很重要的，只有这样才能让所有人更
轻松的阅读和理解代码。

## 行长度

> **每一行代码字符数不超过80**


### 优点
提倡该原则的人认为：
+ 80列宽是传统标准
+ 如果并排开多个代码窗口，根本没有多余空间拉伸窗口
+ 不同的显示器宽度不同，统一80字符可以满足在多个显示设备上都能将一行完整的显示出来

### 缺点
反对该原则的人则认为:
+ 更宽的代码行更易阅读
+ 80列宽的限制是过时的限制
+ 现代的显示设备宽度足够，可以显示更多代码


### 结论

代码尽量保持80字符的限制。

如果无法在不伤害易读性的条件下断行，注释行可以超过80个字符，这样方便复制粘贴。例如带有命名实例或者URL的行就可能超过80个字符

包含长路径的`#include`可超过80字符

**头文件保护**可超过80个字符

## 非ASCII码字符



## 空格还是制表位
> **只是用空格，每次缩进4个空格**

使用空格缩进，不要再代码中使用制表符。可以通过设置编辑器将制表符转换成空格。



## 函数声明和定义

> **返回类型和函数名在同一行，参数也尽量放在同一行，如果放不下就对形参分行，分行方式与函数调用一致**

举例:

	ReturnType functionName(Type parName1, Type parName2) {
	
	...
	
	}

	
如果同一行太多文本，放不下所有参数:

	ReturnTYpe functionName(Type parName1, Type parName2,
	                        Type parName3) {
						
        ...
	}
	
甚至连第一个参数都放不下L

	ReturnTYpe functionName(
	    Type parName1, 
	    Type parName2,
	    Type parName3) {
						
        ...
	}
注意一下几点:
+ 使用好的参数名
+ 如果返回类型和函数名在一行不放不下，分行
+ 如果返回类型和函数名或者定义分行了，不要缩进
+ 左园括号和函数名在同一行
+ 函数名和左圆括号间永远没有空格
+ 圆括号与参数间没有空格
+ 左大括号总是最后一个参数同一行的末尾处，不另起新行
+ 右大括号总是单独位于函数的最后一行，或者与左大括号同行
+ 右圆括号和左大括号之间总有一个空格
+ 所有形参应尽可能对齐
+ 换行后的参数保持4个空格的缩进


## 函数调用
> **要么一行写完函数调用，要么在圆括号内参数分行，要么参数另起一行且缩进4个空格**

一行写完函数调用:

	int counter = doSomeThing(arg1, arg2, arg3);
	

如果同一行放不下，可以断开多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格）:

	int counter = doSomeThing(aVeriVeriVeriVeriLonngArg1, 
	                          arg2, arg3);	
							  
参数也可以放在次行，缩进4个空格:

	doSomeThing(
	    arg1, arg2,
	    arg3, arg4);

把多个参数放在同一行以减少函数调用所需要的行数，除非影响到可读性。


如果一些参数本身就是略复杂的表达式，且降低了可读性，那么可以采用创建临时变量描述该表达式，并传递给函数
举例：
	tempResult = aVeryLongExpression;
	doSomeThing1(result, arg1, arg2);
	
此外，如果一系列参数本身有一定的结构，可以酌情的按其结构来决定参数格式:

	transformMatrix(x1, x2, x3,
	                y1, y2, y3,
	                z1, z2, z3);

**记住，参数的处理格式应当以其可读性而非其他作为最重要的原则。**

## 列表初始化

> **列表初始化保持和函数调用一样的规则**

如果列表初始化伴随着名字，比如类型或者变量名，格式化时将名字视作函数调用，`{}`视作函数调用的括号，如果没有名字，就视作名字长度为0.

举例:
 
	// 写在一行
	return {foo, bar};
	
	// 断行
	MyStruct var = {
	    superLongVariableName1,
        superLongVariableName2,
	    {initValue1, initValue2, initValue3},
	    {superLongInitValue1,
         superLongInitvalue2}};


## 条件语句
> **倾向于不再圆括号内使用空格。关键字`if`和`else`另起一行.**

对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.

最常见的是没有空格的格式. 哪一种都可以, 最重要的是 保持一致. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.

	if (condition1) { // 圆括号内务空格
	    .... // 4个空格缩进
	} else if (condition2) { // else 与 if 与右括号同行
	    ....
	} else {
	    ....
	};
	
如果你更喜欢在圆括号内加空格

	if ( condition ) { // 圆括号内务空格
	    .... // 4个空格缩进
	} else { // else 与 if 与右括号同行
	    ....
	};
注意所有情况下
+ `if`和左圆括号间都有个空格
+ 右圆括号和左大括号间也要有个空格

如果能增强可读性，简短的条件语句允许写在同一行.只有当条件语句简单并且没有使用`else`时才可以

	if (condition) doSomeThingShort();
	
如果语句有`else`分支则不允许

	// definitely NOT write like this
	if (condition) doThis():
	else doThat();

通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 
**如果有些项目或者编程规范强制要求`if`必须总是使用大括号，只能依照强制要求处理**

	if (condition) 
	    doSomeThing();
		
	if (condition) {
	    doSomeThing();
	};

但是如果语句中有个`if-else`分支使用了大括号。其他分支必须使用


	// DO NOT WRITE LIKE THIS
	if (condition) {
	    foo;
	} else
	    bar;
	
	if (condition)
	    foo;
	else {
	    bar;
	}

	
## 循环语句和开关选择语句
> **`switch`语句可以使用大括号分段，表明`case`之间不是连在一起的。在单语句循环内，括号可用可不用。空循环体使用`{}`或者`continue`**

`switch`语句中`case`语句块可以使用大括号也可以不用，取决与个人爱好。如果要用的话，采用下面举例的方式。

如果不满足`case`条件的枚举值，`switch`应总包含`default`以匹配。如果`default`按照设计应该永远执行不到，可以考虑使用断言。

	switch (var) {
	    case 0: { //4空格
		    ... 
			break;
		}
		case 1: {
		    ...
		}
		default: {
		    assert(false);
	    }
	}
	
在单语句循环里，`{}`可用可不用。**如果有些项目或者编程规范强制要求必须总是使用大括号，只能依照强制要求处理**

	for (int i = 0; i < someNumber; i ++)
	    doSomeThing();
		

	for (int i = 0; i < someNumber; i ++) {
	    doSomeThing();
	}

空循环应用`{}`或者`continue`，而不是简单的分号`;`

	while (condition) {
	    // empey loop
	}
	
	while (condition) continue;
	
	// Not like this
	while (condition) ;

## 指针表达式
> **句点或者箭头前后不要有空格。指针/取址操作符(`*`,`&`)之后不能有空格**

推荐的指针或者取址方式：

	x = *p;
	p = &x;
	y = p.x;
	z = p->x;
	
在声明指针变量或者参数时，`*`与类型或者变量名紧挨都可以

	// 空格前置
	char *c;
	MyStruct *var;
	
	// 空格后置
	char* c;
	MyStruct* var;
	
下列的情况不允许:

	int x, *y;
	char * c;
	

## 布尔表达式
> **如果布尔表达式要断行，其方式应统一**	

逻辑运算符位于行尾或者开头都可以，可以考虑额外插入圆括号。但是请保持统一。合理使用的话对增强可读性是很有帮助的. 

比如，

	if (aVeryLongLogicExpre1 &&
	    aVeryLongLogicExper2) { //第二个表达式和第一个表达式对齐
        ...
	}

推荐将逻辑操作符置于行尾
	
## 函数返回值
> **不要在`return`语句中加入不必要的`()`**

只有在写类似`x = exper`要加括号时才会在`return expr`中加括号. 

	// good return expression
	return result;
	return (condition1 && condition2);
	
	// bad return expression
	return (result); // you will never write var =(value)
	return(result);  // return is a keyword not function

## 预处理指令
> **预处理指令不要缩进，从行首开始**

即使预处理指令位于缩进的代码中，也应该从行首开始. `#`后要空格

	// Good
	    ...
	    if (condition) { // 已有4空格缩进
	#if CONDITION
	        doSomeThing;   
	#endif

	        ...
		}
	// Space is not nesseory after #
	    ...
	    if (condition) { // 已有4空格缩进
	# if CONDITION
	        doSomeThing;   
	# endif

	        ...
		}
		
	// bad
	    ...
	    if (condition) { // 已有4空格缩进
	    #if CONDITION
	        doSomeThing;   
	    #endif

	        ...
		}	

## 水平留白
> **水平留白的使用根据其在代码中的位置而定。但是永远不要再行尾添加没意义的留白**

适当的留白，更让代码的排版更加舒适，阅读起来方便。但是同一的项目，特别是同一文件，水平留白的风格建议统一，不要混杂。

### 通用

	void f(bool b) {  // 左大括号前总是有空格.
	...
	int i = 0;  // 分号前不加空格.
	// 列表初始化中大括号内的空格是可选的.
	// 如果加了空格, 那么两边都要加上.
	int x[] = { 0 };
	int x[] = {0};
	void Reset() { baz_ = 0; }  // 用括号把大括号与实现分开.

添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉

### 循环和条件语句

	if (b) {          // if 条件语句和循环语句关键字后均有空格.
	} else {          // else 前后有空格.
	}
	
	while (test) {}   // 圆括号内部不紧邻空格.
	
	switch (i) {
	for (int i = 0; i < 5; ++i) {
	switch ( i ) {    // 循环和条件语句的圆括号里可以与空格紧邻.
	if ( test ) {     // 圆括号, 但这很少见. 总之要一致.
	for ( int i = 0; i < 5; ++i ) {
	for ( ; i < 5 ; ++i) {  // 循环里内 ; 后恒有空格, ;  前可以加个空格.
	switch (i) {
	    case 1:         // switch case 的冒号前无空格.
		...
	    case 2: break;  // 如果冒号有代码, 加个空格.
		

### 操作符

	// 赋值运算符前后总是有空格.
	x = 0;

	// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.
	// 圆括号内部没有紧邻空格.
	v = w * x + y / z;
	v = w*x + y/z;
	v = w * (x + z);

	// 在参数和一元操作符之间不加空格.
	x = -5;
	++x;
	if (x && !y)



	
## 垂直留白
> **垂直留白越少越好**

不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过**2**行, 函数体**首尾**不要留空行, 函数体中也不要随意添加空行.

基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好.

下面的规则可以让加入的空行更有效:
+ 函数体内开头或结尾的空行可读性微乎其微.
+ 在多重 `if-else` 块里加空行或许有点可读性.
+ 逻辑流程转换的地方可以添加空行，用于区别提醒
		
		
******
# C语言特性

## `const`用法
> **如果函数不会修改传你入的指针类型参数, 该参数应声明为`const`**


如果你不希望某个函数参数在运行时被意外的改变，请在声明该参数为`const`类型，
大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值.

## 预处理宏

宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.

宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 # 字符串化, 用 ## 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.

下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:
+ 对于需要在 .h 文件中定义的宏，请确保不会导致命名的冲突
+ 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；
+ 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.
+ 不要用 ## 处理函数，类和变量的名字。

## `0`, `0.0`和`NULL`
> **整数使用`0`, 浮点数使用`0.0`, 指针使用`NULL`，字符使用``\0``**


## `sizeof`的使用
> **尽量使用`sizeof(varname)`，而不是`sizeof(type)`**

使用`sizeof(varname)`是因为当代码中变量类型改变时会自动更新. 
处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，才使用`sizeof(type)`

 

******
# 例外
世事无常，总有例外。下面探讨一些特例。如有必要可以在后续添加编辑.

## 既有的不符和规范的代码
> **对于现有的不符合编程风格的代码，可以网开一面**

当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住, **一致性** 也包括原有的一致性.


